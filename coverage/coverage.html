
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>grafana-kiosk: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/grafana/grafana-kiosk/pkg/cmd/grafana-kiosk/main.go (0.0%)</option>
				
				<option value="file1">github.com/grafana/grafana-kiosk/pkg/initialize/lxde.go (0.0%)</option>
				
				<option value="file2">github.com/grafana/grafana-kiosk/pkg/kiosk/anonymous_login.go (0.0%)</option>
				
				<option value="file3">github.com/grafana/grafana-kiosk/pkg/kiosk/grafana_com_login.go (0.0%)</option>
				
				<option value="file4">github.com/grafana/grafana-kiosk/pkg/kiosk/grafana_genericoauth_login.go (0.0%)</option>
				
				<option value="file5">github.com/grafana/grafana-kiosk/pkg/kiosk/listen_chrome_events.go (0.0%)</option>
				
				<option value="file6">github.com/grafana/grafana-kiosk/pkg/kiosk/local_login.go (0.0%)</option>
				
				<option value="file7">github.com/grafana/grafana-kiosk/pkg/kiosk/utils.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"
        "net/url"
        "os"

        "github.com/ilyakaznacheev/cleanenv"

        "github.com/grafana/grafana-kiosk/pkg/initialize"
        "github.com/grafana/grafana-kiosk/pkg/kiosk"
)

// Args command-line parameters
type Args struct {
        AutoFit                 bool
        IgnoreCertificateErrors bool
        IsPlayList              bool
        OauthAutoLogin          bool
        LXDEEnabled             bool
        LXDEHome                string
        ConfigPath              string
        Mode                    string
        LoginMethod             string
        URL                     string
        Username                string
        Password                string
        UsernameField           string
        PasswordField           string
        WindowPosition          string
}

// ProcessArgs processes and handles CLI arguments
func ProcessArgs(cfg interface{}) Args <span class="cov0" title="0">{
        var a Args

        f := flag.NewFlagSet("grafana-kiosk", flag.ContinueOnError)
        f.StringVar(&amp;a.ConfigPath, "c", "", "Path to configuration file (config.yaml)")
        f.StringVar(&amp;a.LoginMethod, "login-method", "anon", "[anon|local|gcom|goauth]")
        f.StringVar(&amp;a.Username, "username", "guest", "username")
        f.StringVar(&amp;a.Password, "password", "guest", "password")
        f.StringVar(&amp;a.Mode, "kiosk-mode", "full", "Kiosk Display Mode [full|tv|disabled]\nfull = No TOPNAV and No SIDEBAR\ntv = No SIDEBAR\ndisabled = omit option\n")
        f.StringVar(&amp;a.URL, "URL", "https://play.grafana.org", "URL to Grafana server")
        f.StringVar(&amp;a.WindowPosition, "window-position", "0,0", "Top Left Position of Kiosk")
        f.BoolVar(&amp;a.IsPlayList, "playlists", false, "URL is a playlist")
        f.BoolVar(&amp;a.AutoFit, "autofit", true, "Fit panels to screen")
        f.BoolVar(&amp;a.LXDEEnabled, "lxde", false, "Initialize LXDE for kiosk mode")
        f.StringVar(&amp;a.LXDEHome, "lxde-home", "/home/pi", "Path to home directory of LXDE user running X Server")
        f.BoolVar(&amp;a.IgnoreCertificateErrors, "ignore-certificate-errors", false, "Ignore SSL/TLS certificate error")
        f.BoolVar(&amp;a.OauthAutoLogin, "auto-login", false, "oauth_auto_login is enabled in grafana config")
        f.StringVar(&amp;a.UsernameField, "field-username", "username", "Fieldname for the username")
        f.StringVar(&amp;a.PasswordField, "field-password", "password", "Fieldname for the password")

        fu := f.Usage
        f.Usage = func() </span><span class="cov0" title="0">{
                fu()
                envHelp, _ := cleanenv.GetDescription(cfg, nil)
                fmt.Fprintln(f.Output())
                fmt.Fprintln(f.Output(), envHelp)
        }</span>

        <span class="cov0" title="0">err := f.Parse(os.Args[1:])
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(-1)
        }</span>
        <span class="cov0" title="0">return a</span>
}

func setEnvironment() <span class="cov0" title="0">{
        // for linux/X display must be set
        var displayEnv = os.Getenv("DISPLAY")
        if displayEnv == "" </span><span class="cov0" title="0">{
                log.Println("DISPLAY not set, autosetting to :0.0")
                os.Setenv("DISPLAY", ":0.0")
                displayEnv = os.Getenv("DISPLAY")
        }</span>
        <span class="cov0" title="0">log.Println("DISPLAY=", displayEnv)

        var xAuthorityEnv = os.Getenv("XAUTHORITY")
        if xAuthorityEnv == "" </span><span class="cov0" title="0">{
                log.Println("XAUTHORITY not set, autosetting")
                // use HOME of current user
                var homeEnv = os.Getenv("HOME")
                os.Setenv("XAUTHORITY", homeEnv+"/.Xauthority")
                xAuthorityEnv = os.Getenv("XAUTHORITY")
        }</span>
        <span class="cov0" title="0">log.Println("XAUTHORITY=", xAuthorityEnv)</span>
}

func summary(cfg *kiosk.Config) <span class="cov0" title="0">{
        // general
        log.Println("AutoFit:", cfg.General.AutoFit)
        log.Println("LXDEEnabled:", cfg.General.LXDEEnabled)
        log.Println("LXDEHome:", cfg.General.LXDEHome)
        log.Println("Mode:", cfg.General.Mode)
        log.Println("WindowPosition:", cfg.General.WindowPosition)
        // target
        log.Println("URL:", cfg.Target.URL)
        log.Println("LoginMethod:", cfg.Target.LoginMethod)
        log.Println("Username:", cfg.Target.Username)
        log.Println("Password:", "*redacted*")
        log.Println("IgnoreCertificateErrors:", cfg.Target.IgnoreCertificateErrors)
        log.Println("IsPlayList:", cfg.Target.IsPlayList)
        // goauth
        log.Println("Fieldname Username:", cfg.GOAUTH.AutoLogin)
        log.Println("Fieldname Username:", cfg.GOAUTH.UsernameField)
        log.Println("Fieldname Password:", cfg.GOAUTH.PasswordField)
}</span>

func main() <span class="cov0" title="0">{
        var cfg kiosk.Config
        // override
        args := ProcessArgs(&amp;cfg)
        // check if config specified
        if args.ConfigPath != "" </span><span class="cov0" title="0">{
                // read configuration from the file and then override with environment variables
                if err := cleanenv.ReadConfig(args.ConfigPath, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                        log.Println("Error reading config file", err)
                        os.Exit(-1)
                }</span> else<span class="cov0" title="0"> {
                        log.Println("Using config from", args.ConfigPath)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("No config specified, using environment and args")
                // no config, use environment and args
                if err := cleanenv.ReadEnv(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                        log.Println("Error reading config from environment", err)
                }</span>
                <span class="cov0" title="0">cfg.Target.URL = args.URL
                cfg.Target.LoginMethod = args.LoginMethod
                cfg.Target.Username = args.Username
                cfg.Target.Password = args.Password
                cfg.Target.IgnoreCertificateErrors = args.IgnoreCertificateErrors
                cfg.Target.IsPlayList = args.IsPlayList
                //
                cfg.General.AutoFit = args.AutoFit
                cfg.General.LXDEEnabled = args.LXDEEnabled
                cfg.General.LXDEHome = args.LXDEHome
                cfg.General.Mode = args.Mode
                cfg.General.WindowPosition = args.WindowPosition
                //
                cfg.GOAUTH.AutoLogin = args.OauthAutoLogin
                cfg.GOAUTH.UsernameField = args.UsernameField
                cfg.GOAUTH.PasswordField = args.PasswordField</span>
        }
        <span class="cov0" title="0">summary(&amp;cfg)
        // make sure the url has content
        if cfg.Target.URL == "" </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
        // validate url
        <span class="cov0" title="0">_, err := url.ParseRequestURI(cfg.Target.URL)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">summary(&amp;cfg)

        if cfg.General.LXDEEnabled </span><span class="cov0" title="0">{
                initialize.LXDE(cfg.General.LXDEHome)
        }</span>

        // for linux/X display must be set
        <span class="cov0" title="0">setEnvironment()
        log.Println("method ", cfg.Target.LoginMethod)

        switch cfg.Target.LoginMethod </span>{
        case "local":<span class="cov0" title="0">
                log.Printf("Launching local login kiosk")
                kiosk.GrafanaKioskLocal(&amp;cfg)</span>
        case "gcom":<span class="cov0" title="0">
                log.Printf("Launching GCOM login kiosk")
                kiosk.GrafanaKioskGCOM(&amp;cfg)</span>
        case "goauth":<span class="cov0" title="0">
                log.Printf("Launching Generic Oauth login kiosk")
                kiosk.GrafanaKioskGenericOauth(&amp;cfg)</span>
        default:<span class="cov0" title="0">
                log.Printf("Launching ANON login kiosk")
                kiosk.GrafanaKioskAnonymous(&amp;cfg)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package initialize

import (
        "log"
        "os"
        "os/exec"
)

// LXDE runs shell commands to setup LXDE for kiosk mode
func LXDE(path string) <span class="cov0" title="0">{
        var command = "/usr/bin/lxpanel"

        args := []string{"--profile", "LXDE"}
        runCommand(path, command, args, true)
        command = "/usr/bin/pcmanfm"
        args = []string{"--desktop", "--profile", "LXDE"}
        runCommand(path, command, args, true)
        command = "/usr/bin/xset"
        runCommand(path, command, args, true)
        args = []string{"s", "off"}
        runCommand(path, command, args, true)
        args = []string{"-dpms"}
        runCommand(path, command, args, true)
        args = []string{"s", "noblank"}
        runCommand(path, command, args, true)
        command = "/usr/bin/unclutter"
        displayEnv := os.Getenv("DISPLAY")
        args = []string{"-display", displayEnv, "-idle", "5"}

        go runCommand(path, command, args, true)
}</span>

func runCommand(path string, command string, args []string, waitForEnd bool) <span class="cov0" title="0">{
        // check if command exists
        log.Printf("path: %v", path)
        log.Printf("command: %v", command)
        log.Printf("arg0: %v", args[0])
        cmd := exec.Command(command, args...)
        cmd.Env = append(os.Environ(),
                "DISPLAY=:0.0",
                "XAUTHORITY="+path+"/.Xauthority",
        )
        err := cmd.Start()
        if err != nil </span><span class="cov0" title="0">{
                //log.Printf(err)
                log.Printf("Error in output, ignoring...")
        }</span>
        <span class="cov0" title="0">if waitForEnd </span><span class="cov0" title="0">{
                log.Printf("Waiting for command to finish...")
                err = cmd.Wait()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Command finished with error: %v", err)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package kiosk

import (
        "context"
        "io/ioutil"
        "log"
        "os"
        "time"

        "github.com/chromedp/chromedp"
)

// GrafanaKioskAnonymous creates a chrome-based kiosk using a local grafana-server account
func GrafanaKioskAnonymous(cfg *Config) <span class="cov0" title="0">{
        dir, err := ioutil.TempDir("", "chromedp-example")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer os.RemoveAll(dir)

        opts := []chromedp.ExecAllocatorOption{
                chromedp.NoFirstRun,
                chromedp.NoDefaultBrowserCheck,
                chromedp.Flag("noerrdialogs", true),
                chromedp.Flag("kiosk", true),
                chromedp.Flag("bwsi", true),
                chromedp.Flag("incognito", true),
                chromedp.Flag("disable-sync", true),
                chromedp.Flag("disable-notifications", true),
                chromedp.Flag("disable-overlay-scrollbar", true),
                chromedp.Flag("ignore-certificate-errors", cfg.Target.IgnoreCertificateErrors),
                chromedp.Flag("test-type", cfg.Target.IgnoreCertificateErrors),
                chromedp.Flag("window-position", cfg.General.WindowPosition),
                chromedp.Flag("check-for-update-interval", "31536000"),
                chromedp.UserDataDir(dir),
        }

        allocCtx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)
        defer cancel()

        // also set up a custom logger
        taskCtx, cancel := chromedp.NewContext(allocCtx, chromedp.WithLogf(log.Printf))
        defer cancel()

        listenChromeEvents(taskCtx, consoleAPICall|targetCrashed)

        // ensure that the browser process is started
        if err := chromedp.Run(taskCtx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Give browser time to load next page (this can be prone to failure, explore different options vs sleeping)
        <span class="cov0" title="0">time.Sleep(2000 * time.Millisecond)

        var generatedURL = GenerateURL(cfg.Target.URL, cfg.General.Mode, cfg.General.AutoFit, cfg.Target.IsPlayList)
        log.Println("Navigating to ", generatedURL)
        /*
                Launch chrome and look for main-view element
        */
        if err := chromedp.Run(taskCtx,
                chromedp.Navigate(generatedURL),
                chromedp.WaitVisible(`//div[@class="main-view"]`, chromedp.BySearch),
                // wait forever (for now)
                chromedp.WaitVisible("notinputPassword", chromedp.ByID),
        ); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">log.Println("Sleep before exit...")
        // wait here for the process to exit
        time.Sleep(2000 * time.Millisecond)
        log.Println("Exit...")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package kiosk

import (
        "context"
        "io/ioutil"
        "log"
        "os"
        "time"

        "github.com/chromedp/chromedp"
        "github.com/chromedp/chromedp/kb"
)

// GrafanaKioskGCOM creates a chrome-based kiosk using a grafana.com authenticated account
func GrafanaKioskGCOM(cfg *Config) <span class="cov0" title="0">{
        dir, err := ioutil.TempDir("", "chromedp-example")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer os.RemoveAll(dir)

        opts := []chromedp.ExecAllocatorOption{
                chromedp.NoFirstRun,
                chromedp.NoDefaultBrowserCheck,
                chromedp.Flag("noerrdialogs", true),
                chromedp.Flag("kiosk", true),
                chromedp.Flag("bwsi", true),
                chromedp.Flag("incognito", true),
                chromedp.Flag("disable-sync", true),
                chromedp.Flag("disable-notifications", true),
                chromedp.Flag("disable-overlay-scrollbar", true),
                chromedp.Flag("window-position", cfg.General.WindowPosition),
                chromedp.Flag("check-for-update-interval", "31536000"),
                chromedp.UserDataDir(dir),
        }

        allocCtx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)
        defer cancel()

        // also set up a custom logger
        taskCtx, cancel := chromedp.NewContext(allocCtx, chromedp.WithLogf(log.Printf))
        defer cancel()

        listenChromeEvents(taskCtx, targetCrashed)

        // ensure that the browser process is started
        if err := chromedp.Run(taskCtx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var generatedURL = GenerateURL(cfg.Target.URL, cfg.General.Mode, cfg.General.AutoFit, cfg.Target.IsPlayList)
        log.Println("Navigating to ", generatedURL)

        /*
                Launch chrome, click the grafana.com button, fill out login form and submit
        */
        // XPATH of grafana.com login button = //*[@href="login/grafana_com"]/i
        // XPATH for grafana.com login (new) = //a[contains(@href,'login/grafana_com')]

        //chromedp.WaitVisible(`//*[@href="login/grafana_com"]/i`, chromedp.BySearch),

        // Click the grafana_com login button
        if err := chromedp.Run(taskCtx,
                chromedp.Navigate(generatedURL),
                chromedp.ActionFunc(func(context.Context) error </span><span class="cov0" title="0">{
                        log.Println("waiting for login dialog")
                        return nil
                }</span>),
                chromedp.WaitVisible(`//a[contains(@href,'login/grafana_com')]`, chromedp.BySearch),
                chromedp.ActionFunc(func(context.Context) error <span class="cov0" title="0">{
                        log.Println("gcom login dialog detected")
                        return nil
                }</span>),
                chromedp.Click(`//a[contains(@href,'login/grafana_com')]/..`, chromedp.BySearch),
                chromedp.ActionFunc(func(context.Context) error <span class="cov0" title="0">{
                        log.Println("gcom button clicked")
                        return nil
                }</span>),
        ); err != nil <span class="cov0" title="0">{
                panic(err)</span>
        }
        // Give browser time to load next page (this can be prone to failure, explore different options vs sleeping)
        <span class="cov0" title="0">time.Sleep(2000 * time.Millisecond)
        // Fill out grafana_com login page
        if err := chromedp.Run(taskCtx,
                chromedp.WaitVisible(`//input[@name="login"]`, chromedp.BySearch),
                chromedp.SendKeys(`//input[@name="login"]`, cfg.Target.Username, chromedp.BySearch),
                chromedp.SendKeys(`//input[@name="password"]`, cfg.Target.Password+kb.Enter, chromedp.BySearch),
                chromedp.WaitVisible(`notinputPassword`, chromedp.ByID),
        ); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package kiosk

import (
        "context"
        "io/ioutil"
        "log"
        "os"
        "time"

        "github.com/chromedp/chromedp"
        "github.com/chromedp/chromedp/kb"
)

// GrafanaKioskGenericOauth creates a chrome-based kiosk using a oauth2 authenticated account
func GrafanaKioskGenericOauth(cfg *Config) <span class="cov0" title="0">{
        dir, err := ioutil.TempDir("", "chromedp-example")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer os.RemoveAll(dir)

        opts := []chromedp.ExecAllocatorOption{
                chromedp.NoFirstRun,
                chromedp.NoDefaultBrowserCheck,
                chromedp.Flag("noerrdialogs", true),
                chromedp.Flag("kiosk", true),
                chromedp.Flag("bwsi", true),
                chromedp.Flag("incognito", true),
                chromedp.Flag("disable-sync", true),
                chromedp.Flag("disable-notifications", true),
                chromedp.Flag("disable-overlay-scrollbar", true),
                chromedp.Flag("window-position", cfg.General.WindowPosition),
                chromedp.Flag("check-for-update-interval", "31536000"),
                chromedp.UserDataDir(dir),
        }

        allocCtx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)
        defer cancel()

        // also set up a custom logger
        taskCtx, cancel := chromedp.NewContext(allocCtx, chromedp.WithLogf(log.Printf))
        defer cancel()

        listenChromeEvents(taskCtx, targetCrashed)

        // ensure that the browser process is started
        if err := chromedp.Run(taskCtx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var generatedURL = GenerateURL(cfg.Target.URL, cfg.General.Mode, cfg.General.AutoFit, cfg.Target.IsPlayList)
        log.Println("Navigating to ", generatedURL)

        /*
                Launch chrome, click the GENERIC OAUTH button, fill out login form and submit
        */
        // XPATH of grafana.com for Generic OAUTH login button = //*[@href="login/grafana_com"]/i

        // Click the OAUTH login button
        log.Println("Oauth_Auto_Login enabled: ", cfg.GOAUTH.AutoLogin)
        if cfg.GOAUTH.AutoLogin </span><span class="cov0" title="0">{
                if err := chromedp.Run(taskCtx,
                        chromedp.Navigate(generatedURL),
                ); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        } else<span class="cov0" title="0"> {
                if err := chromedp.Run(taskCtx,
                        chromedp.Navigate(generatedURL),
                        chromedp.WaitVisible(`//*[@href="login/generic_oauth"]`, chromedp.BySearch),
                        chromedp.Click(`//*[@href="login/generic_oauth"]`, chromedp.BySearch),
                ); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }

        // Give browser time to load next page (this can be prone to failure, explore different options vs sleeping)
        <span class="cov0" title="0">time.Sleep(2000 * time.Millisecond)
        // Fill out OAUTH login page
        if err := chromedp.Run(taskCtx,
                chromedp.WaitVisible(`//input[@name="`+cfg.GOAUTH.UsernameField+`"]`, chromedp.BySearch),
                chromedp.SendKeys(`//input[@name="`+cfg.GOAUTH.UsernameField+`"]`, cfg.Target.Username, chromedp.BySearch),
                chromedp.SendKeys(`//input[@name="`+cfg.GOAUTH.PasswordField+`"]`, cfg.Target.Password+kb.Enter, chromedp.BySearch),
                chromedp.WaitVisible(`notinputPassword`, chromedp.ByID),
        ); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package kiosk

import (
        "context"
        "log"

        "github.com/chromedp/cdproto/inspector"
        "github.com/chromedp/cdproto/runtime"
        "github.com/chromedp/chromedp"
)

type chromeEvents int

const (
        consoleAPICall chromeEvents = 1 &lt;&lt; iota
        targetCrashed
)

func listenChromeEvents(taskCtx context.Context, events chromeEvents) <span class="cov0" title="0">{
        chromedp.ListenTarget(taskCtx, func(ev interface{}) </span><span class="cov0" title="0">{
                switch ev := ev.(type) </span>{
                case *runtime.EventConsoleAPICalled:<span class="cov0" title="0">
                        if events&amp;consoleAPICall != 0 </span><span class="cov0" title="0">{
                                log.Printf("console.%s call:\n", ev.Type)
                                for _, arg := range ev.Args </span><span class="cov0" title="0">{
                                        log.Printf("        %s - %s\n", arg.Type, arg.Value)
                                }</span>
                        }
                case *inspector.EventTargetCrashed:<span class="cov0" title="0">
                        if events&amp;targetCrashed != 0 </span><span class="cov0" title="0">{
                                log.Printf("target crashed, reload...")
                                go func() </span><span class="cov0" title="0">{
                                        _ = chromedp.Run(taskCtx, chromedp.Reload())
                                }</span>()
                        }
                }
        })
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package kiosk

import (
        "context"
        "io/ioutil"
        "log"
        "os"
        "time"

        "github.com/chromedp/chromedp"
        "github.com/chromedp/chromedp/kb"
)

// GrafanaKioskLocal creates a chrome-based kiosk using a local grafana-server account
func GrafanaKioskLocal(cfg *Config) <span class="cov0" title="0">{
        dir, err := ioutil.TempDir("", "chromedp-example")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">defer os.RemoveAll(dir)

        opts := []chromedp.ExecAllocatorOption{
                chromedp.NoFirstRun,
                chromedp.NoDefaultBrowserCheck,
                chromedp.Flag("noerrdialogs", true),
                chromedp.Flag("kiosk", true),
                chromedp.Flag("bwsi", true),
                chromedp.Flag("incognito", true),
                chromedp.Flag("disable-sync", true),
                chromedp.Flag("disable-notifications", true),
                chromedp.Flag("disable-overlay-scrollbar", true),
                chromedp.Flag("ignore-certificate-errors", cfg.Target.IgnoreCertificateErrors),
                chromedp.Flag("test-type", cfg.Target.IgnoreCertificateErrors),
                chromedp.Flag("window-position", cfg.General.WindowPosition),
                chromedp.Flag("check-for-update-interval", "31536000"),
                chromedp.UserDataDir(dir),
        }

        allocCtx, cancel := chromedp.NewExecAllocator(context.Background(), opts...)
        defer cancel()

        // also set up a custom logger
        taskCtx, cancel := chromedp.NewContext(allocCtx, chromedp.WithLogf(log.Printf))
        defer cancel()

        listenChromeEvents(taskCtx, targetCrashed)

        // ensure that the browser process is started
        if err := chromedp.Run(taskCtx); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">var generatedURL = GenerateURL(cfg.Target.URL, cfg.General.Mode, cfg.General.AutoFit, cfg.Target.IsPlayList)
        log.Println("Navigating to ", generatedURL)
        /*
                Launch chrome and login with local user account

                name=user, type=text
                id=inputPassword, type=password, name=password
        */
        // Give browser time to load next page (this can be prone to failure, explore different options vs sleeping)
        time.Sleep(2000 * time.Millisecond)

        if err := chromedp.Run(taskCtx,
                chromedp.Navigate(generatedURL),
                chromedp.WaitVisible(`//input[@name="user"]`, chromedp.BySearch),
                chromedp.SendKeys(`//input[@name="user"]`, cfg.Target.Username, chromedp.BySearch),
                chromedp.SendKeys(`//input[@name="password"]`, cfg.Target.Password+kb.Enter, chromedp.BySearch),
                chromedp.WaitVisible(`notinputPassword`, chromedp.ByID),
        ); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package kiosk

import (
        "log"
        "net/url"
)

// GenerateURL constructs URL with appropriate parameters for kiosk mode
func GenerateURL(anURL string, kioskMode string, autoFit bool, isPlayList bool) string <span class="cov0" title="0">{
        u, _ := url.ParseRequestURI(anURL)
        q, _ := url.ParseQuery(u.RawQuery)

        switch kioskMode </span>{
        case "tv":<span class="cov0" title="0"> // TV
                q.Set("kiosk", "tv") // no sidebar, topnav without buttons
                log.Printf("KioskMode: TV")</span>
        case "full":<span class="cov0" title="0"> // FULLSCREEN
                q.Set("kiosk", "1") // sidebar and topnav always shown
                log.Printf("KioskMode: Fullscreen")</span>
        case "disabled":<span class="cov0" title="0"> // FULLSCREEN
                log.Printf("KioskMode: Disabled")</span>
        default:<span class="cov0" title="0"> // disabled
                q.Set("kiosk", "1") // sidebar and topnav always shown
                log.Printf("KioskMode: Fullscreen")</span>
        }
        // a playlist should also go inactive immediately
        <span class="cov0" title="0">if isPlayList </span><span class="cov0" title="0">{
                q.Set("inactive", "1")
        }</span>
        <span class="cov0" title="0">u.RawQuery = q.Encode()
        if autoFit </span><span class="cov0" title="0">{
                u.RawQuery += "&amp;autofitpanels"
        }</span>
        <span class="cov0" title="0">return u.String()</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
